/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
// @ts-ignore
import { ChangeTicketHeadRequest } from "../models";
// @ts-ignore
import { ChangeTicketStateRequest } from "../models";
// @ts-ignore
import { ChangeTicketStateResponse } from "../models";
// @ts-ignore
import { CreateBlacklistRecordRequest } from "../models";
// @ts-ignore
import { CreateTicketRequest } from "../models";
// @ts-ignore
import { HelperStats } from "../models";
// @ts-ignore
import { HelperStatsRequest } from "../models";
// @ts-ignore
import { HelpersStatsRequest } from "../models";
// @ts-ignore
import { PredefinedMessage } from "../models";
// @ts-ignore
import { PredefinedMessageRequest } from "../models";
// @ts-ignore
import { RateTicketRequest } from "../models";
// @ts-ignore
import { ResponsePageTicketBlacklistDTO } from "../models";
// @ts-ignore
import { ResponsePageTicketInfo } from "../models";
// @ts-ignore
import { ResultResponse } from "../models";
// @ts-ignore
import { SendTicketMessageRequest } from "../models";
// @ts-ignore
import { SetDuplicateResponse } from "../models";
// @ts-ignore
import { SetStarRequest } from "../models";
// @ts-ignore
import { SetTicketNoteRequest } from "../models";
// @ts-ignore
import { TicketBlacklist } from "../models";
// @ts-ignore
import { TicketDTO } from "../models";
// @ts-ignore
import { TicketFilters } from "../models";
// @ts-ignore
import { TicketMessageDTO } from "../models";
// @ts-ignore
import { TicketRating } from "../models";
// @ts-ignore
import { TicketType } from "../models";
/**
 * TicketsControllerApi - axios parameter creator
 * @export
 */
export const TicketsControllerApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToBlacklist: async (
      createBlacklistRecordRequest: CreateBlacklistRecordRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createBlacklistRecordRequest' is not null or undefined
      assertParamExists(
        "addUserToBlacklist",
        "createBlacklistRecordRequest",
        createBlacklistRecordRequest,
      );
      const localVarPath = `/tickets/blacklist`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createBlacklistRecordRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTicketByUid: async (
      uid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("closeTicketByUid", "uid", uid);
      const localVarPath = `/tickets/{uid}/close`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {PredefinedMessageRequest} predefinedMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPredefinedMessage: async (
      uuid: string,
      predefinedMessageRequest: PredefinedMessageRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("createPredefinedMessage", "uuid", uuid);
      // verify required parameter 'predefinedMessageRequest' is not null or undefined
      assertParamExists(
        "createPredefinedMessage",
        "predefinedMessageRequest",
        predefinedMessageRequest,
      );
      const localVarPath = `/tickets/user/{uuid}/predefinedmessages`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        predefinedMessageRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateTicketRequest} createTicketRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTicket: async (
      createTicketRequest: CreateTicketRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createTicketRequest' is not null or undefined
      assertParamExists(
        "createTicket",
        "createTicketRequest",
        createTicketRequest,
      );
      const localVarPath = `/tickets/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTicketRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessage: async (
      uid: string,
      messageUid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("deleteMessage", "uid", uid);
      // verify required parameter 'messageUid' is not null or undefined
      assertParamExists("deleteMessage", "messageUid", messageUid);
      const localVarPath = `/tickets/{uid}/message/{messageUid}`
        .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
        .replace(`{${"messageUid"}}`, encodeURIComponent(String(messageUid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePredefinedMessage: async (
      uuid: string,
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("deletePredefinedMessage", "uuid", uuid);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deletePredefinedMessage", "id", id);
      const localVarPath = `/tickets/user/{uuid}/predefinedmessages/{id}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUid
     * @param {SendTicketMessageRequest} sendTicketMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMessage: async (
      uid: string,
      messageUid: string,
      sendTicketMessageRequest: SendTicketMessageRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("editMessage", "uid", uid);
      // verify required parameter 'messageUid' is not null or undefined
      assertParamExists("editMessage", "messageUid", messageUid);
      // verify required parameter 'sendTicketMessageRequest' is not null or undefined
      assertParamExists(
        "editMessage",
        "sendTicketMessageRequest",
        sendTicketMessageRequest,
      );
      const localVarPath = `/tickets/{uid}/message/{messageUid}`
        .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
        .replace(`{${"messageUid"}}`, encodeURIComponent(String(messageUid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sendTicketMessageRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlacklist: async (
      page: number,
      perPage: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getBlacklist", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getBlacklist", "perPage", perPage);
      const localVarPath = `/tickets/blacklist/{page}/{perPage}`
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {HelperStatsRequest} helperStatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHelperStats: async (
      uuid: string,
      helperStatsRequest: HelperStatsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getHelperStats", "uuid", uuid);
      // verify required parameter 'helperStatsRequest' is not null or undefined
      assertParamExists(
        "getHelperStats",
        "helperStatsRequest",
        helperStatsRequest,
      );
      const localVarPath = `/tickets/user/{uuid}/stats`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        helperStatsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {HelpersStatsRequest} helpersStatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHelpersStats: async (
      helpersStatsRequest: HelpersStatsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'helpersStatsRequest' is not null or undefined
      assertParamExists(
        "getHelpersStats",
        "helpersStatsRequest",
        helpersStatsRequest,
      );
      const localVarPath = `/tickets/users/stats`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        helpersStatsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPredefinedMessages: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getPredefinedMessages", "uuid", uuid);
      const localVarPath = `/tickets/user/{uuid}/predefinedmessages`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRatings: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getRatings", "uuid", uuid);
      const localVarPath = `/tickets/user/{uuid}/rating`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketAttachment: async (
      uid: string,
      fileName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("getTicketAttachment", "uid", uid);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists("getTicketAttachment", "fileName", fileName);
      const localVarPath = `/tickets/{uid}/attachments/{fileName}`
        .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
        .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketByUid: async (
      uid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("getTicketByUid", "uid", uid);
      const localVarPath = `/tickets/{uid}`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUuid
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketMessageAttachment: async (
      uid: string,
      messageUuid: string,
      fileName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("getTicketMessageAttachment", "uid", uid);
      // verify required parameter 'messageUuid' is not null or undefined
      assertParamExists(
        "getTicketMessageAttachment",
        "messageUuid",
        messageUuid,
      );
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists("getTicketMessageAttachment", "fileName", fileName);
      const localVarPath =
        `/tickets/{uid}/message/{messageUuid}/attachments/{fileName}`
          .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
          .replace(
            `{${"messageUuid"}}`,
            encodeURIComponent(String(messageUuid)),
          )
          .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTypes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tickets/types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} page
     * @param {number} perPage
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {TicketFilters} [ticketFilters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTickets: async (
      page: number,
      perPage: number,
      sortBy?: string,
      sortDirection?: string,
      ticketFilters?: TicketFilters,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getTickets", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getTickets", "perPage", perPage);
      const localVarPath = `/tickets/all/{page}/{perPage}`
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (sortDirection !== undefined) {
        localVarQueryParameter["sortDirection"] = sortDirection;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        ticketFilters,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTicketsByUserUuid: async (
      uuid: string,
      page: number,
      perPage: number,
      sortBy?: string,
      sortDirection?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getUserTicketsByUserUuid", "uuid", uuid);
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getUserTicketsByUserUuid", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getUserTicketsByUserUuid", "perPage", perPage);
      const localVarPath = `/tickets/user/{uuid}/{page}/{perPage}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (sortBy !== undefined) {
        localVarQueryParameter["sortBy"] = sortBy;
      }

      if (sortDirection !== undefined) {
        localVarQueryParameter["sortDirection"] = sortDirection;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isUserBlacklisted: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("isUserBlacklisted", "uuid", uuid);
      const localVarPath = `/tickets/blacklist/{uuid}`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {SendTicketMessageRequest} sendTicketMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMessage: async (
      uid: string,
      sendTicketMessageRequest: SendTicketMessageRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("postMessage", "uid", uid);
      // verify required parameter 'sendTicketMessageRequest' is not null or undefined
      assertParamExists(
        "postMessage",
        "sendTicketMessageRequest",
        sendTicketMessageRequest,
      );
      const localVarPath = `/tickets/{uid}/message`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sendTicketMessageRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {RateTicketRequest} rateTicketRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rateTicketByUid: async (
      uid: string,
      rateTicketRequest: RateTicketRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("rateTicketByUid", "uid", uid);
      // verify required parameter 'rateTicketRequest' is not null or undefined
      assertParamExists(
        "rateTicketByUid",
        "rateTicketRequest",
        rateTicketRequest,
      );
      const localVarPath = `/tickets/{uid}/rate`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        rateTicketRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeBlacklistRecord: async (
      id: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("removeBlacklistRecord", "id", id);
      const localVarPath = `/tickets/blacklist/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reopenTicketByUid: async (
      uid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("reopenTicketByUid", "uid", uid);
      const localVarPath = `/tickets/{uid}/reopen`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rewardCoins: async (
      uid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("rewardCoins", "uid", uid);
      const localVarPath = `/tickets/{uid}/rewardcoins`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketDuplicate: async (
      uid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("setTicketDuplicate", "uid", uid);
      const localVarPath = `/tickets/{uid}/duplicate`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {ChangeTicketHeadRequest} changeTicketHeadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketHead: async (
      uid: string,
      changeTicketHeadRequest: ChangeTicketHeadRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("setTicketHead", "uid", uid);
      // verify required parameter 'changeTicketHeadRequest' is not null or undefined
      assertParamExists(
        "setTicketHead",
        "changeTicketHeadRequest",
        changeTicketHeadRequest,
      );
      const localVarPath = `/tickets/{uid}/head`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeTicketHeadRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {SetTicketNoteRequest} setTicketNoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketNote: async (
      uid: string,
      setTicketNoteRequest: SetTicketNoteRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("setTicketNote", "uid", uid);
      // verify required parameter 'setTicketNoteRequest' is not null or undefined
      assertParamExists(
        "setTicketNote",
        "setTicketNoteRequest",
        setTicketNoteRequest,
      );
      const localVarPath = `/tickets/{uid}/note`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setTicketNoteRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {SetStarRequest} setStarRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketStar: async (
      uid: string,
      setStarRequest: SetStarRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("setTicketStar", "uid", uid);
      // verify required parameter 'setStarRequest' is not null or undefined
      assertParamExists("setTicketStar", "setStarRequest", setStarRequest);
      const localVarPath = `/tickets/{uid}/star`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setStarRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {ChangeTicketStateRequest} changeTicketStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketState: async (
      uid: string,
      changeTicketStateRequest: ChangeTicketStateRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("setTicketState", "uid", uid);
      // verify required parameter 'changeTicketStateRequest' is not null or undefined
      assertParamExists(
        "setTicketState",
        "changeTicketStateRequest",
        changeTicketStateRequest,
      );
      const localVarPath = `/tickets/{uid}/state`.replace(
        `{${"uid"}}`,
        encodeURIComponent(String(uid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeTicketStateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} id
     * @param {PredefinedMessageRequest} predefinedMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePredefinedMessage: async (
      uuid: string,
      id: number,
      predefinedMessageRequest: PredefinedMessageRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("updatePredefinedMessage", "uuid", uuid);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updatePredefinedMessage", "id", id);
      // verify required parameter 'predefinedMessageRequest' is not null or undefined
      assertParamExists(
        "updatePredefinedMessage",
        "predefinedMessageRequest",
        predefinedMessageRequest,
      );
      const localVarPath = `/tickets/user/{uuid}/predefinedmessages/{id}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        predefinedMessageRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {string} fileName
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadTicketAttachment: async (
      uid: string,
      fileName: string,
      body: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("uploadTicketAttachment", "uid", uid);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists("uploadTicketAttachment", "fileName", fileName);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("uploadTicketAttachment", "body", body);
      const localVarPath = `/tickets/{uid}/attachments/{fileName}`
        .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
        .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUuid
     * @param {string} fileName
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadTicketMessageAttachment: async (
      uid: string,
      messageUuid: string,
      fileName: string,
      body: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uid' is not null or undefined
      assertParamExists("uploadTicketMessageAttachment", "uid", uid);
      // verify required parameter 'messageUuid' is not null or undefined
      assertParamExists(
        "uploadTicketMessageAttachment",
        "messageUuid",
        messageUuid,
      );
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists("uploadTicketMessageAttachment", "fileName", fileName);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("uploadTicketMessageAttachment", "body", body);
      const localVarPath =
        `/tickets/{uid}/message/{messageUuid}/attachments/{fileName}`
          .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
          .replace(
            `{${"messageUuid"}}`,
            encodeURIComponent(String(messageUuid)),
          )
          .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TicketsControllerApi - functional programming interface
 * @export
 */
export const TicketsControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TicketsControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUserToBlacklist(
      createBlacklistRecordRequest: CreateBlacklistRecordRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TicketBlacklist>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addUserToBlacklist(
          createBlacklistRecordRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async closeTicketByUid(
      uid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ChangeTicketStateResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.closeTicketByUid(uid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {PredefinedMessageRequest} predefinedMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPredefinedMessage(
      uuid: string,
      predefinedMessageRequest: PredefinedMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PredefinedMessage>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPredefinedMessage(
          uuid,
          predefinedMessageRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateTicketRequest} createTicketRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTicket(
      createTicketRequest: CreateTicketRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(
        createTicketRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMessage(
      uid: string,
      messageUid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(
        uid,
        messageUid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePredefinedMessage(
      uuid: string,
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePredefinedMessage(
          uuid,
          id,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUid
     * @param {SendTicketMessageRequest} sendTicketMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editMessage(
      uid: string,
      messageUid: string,
      sendTicketMessageRequest: SendTicketMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editMessage(
        uid,
        messageUid,
        sendTicketMessageRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlacklist(
      page: number,
      perPage: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageTicketBlacklistDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBlacklist(
        page,
        perPage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {HelperStatsRequest} helperStatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHelperStats(
      uuid: string,
      helperStatsRequest: HelperStatsRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelperStats>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHelperStats(
        uuid,
        helperStatsRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {HelpersStatsRequest} helpersStatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHelpersStats(
      helpersStatsRequest: HelpersStatsRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<HelperStats>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHelpersStats(
        helpersStatsRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPredefinedMessages(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PredefinedMessage>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPredefinedMessages(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRatings(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TicketRating>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRatings(
        uuid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicketAttachment(
      uid: string,
      fileName: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTicketAttachment(
          uid,
          fileName,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicketByUid(
      uid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketByUid(
        uid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUuid
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicketMessageAttachment(
      uid: string,
      messageUuid: string,
      fileName: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTicketMessageAttachment(
          uid,
          messageUuid,
          fileName,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicketTypes(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<TicketType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketTypes(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {number} page
     * @param {number} perPage
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {TicketFilters} [ticketFilters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTickets(
      page: number,
      perPage: number,
      sortBy?: string,
      sortDirection?: string,
      ticketFilters?: TicketFilters,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageTicketInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTickets(
        page,
        perPage,
        sortBy,
        sortDirection,
        ticketFilters,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserTicketsByUserUuid(
      uuid: string,
      page: number,
      perPage: number,
      sortBy?: string,
      sortDirection?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageTicketInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserTicketsByUserUuid(
          uuid,
          page,
          perPage,
          sortBy,
          sortDirection,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isUserBlacklisted(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TicketBlacklist>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.isUserBlacklisted(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {SendTicketMessageRequest} sendTicketMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postMessage(
      uid: string,
      sendTicketMessageRequest: SendTicketMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TicketMessageDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postMessage(
        uid,
        sendTicketMessageRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {RateTicketRequest} rateTicketRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rateTicketByUid(
      uid: string,
      rateTicketRequest: RateTicketRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rateTicketByUid(
        uid,
        rateTicketRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeBlacklistRecord(
      id: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeBlacklistRecord(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reopenTicketByUid(
      uid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ChangeTicketStateResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.reopenTicketByUid(uid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rewardCoins(
      uid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rewardCoins(
        uid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setTicketDuplicate(
      uid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetDuplicateResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setTicketDuplicate(uid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {ChangeTicketHeadRequest} changeTicketHeadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setTicketHead(
      uid: string,
      changeTicketHeadRequest: ChangeTicketHeadRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketHead(
        uid,
        changeTicketHeadRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {SetTicketNoteRequest} setTicketNoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setTicketNote(
      uid: string,
      setTicketNoteRequest: SetTicketNoteRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketNote(
        uid,
        setTicketNoteRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {SetStarRequest} setStarRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setTicketStar(
      uid: string,
      setStarRequest: SetStarRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketStar(
        uid,
        setStarRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {ChangeTicketStateRequest} changeTicketStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setTicketState(
      uid: string,
      changeTicketStateRequest: ChangeTicketStateRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ChangeTicketStateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketState(
        uid,
        changeTicketStateRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} id
     * @param {PredefinedMessageRequest} predefinedMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePredefinedMessage(
      uuid: string,
      id: number,
      predefinedMessageRequest: PredefinedMessageRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePredefinedMessage(
          uuid,
          id,
          predefinedMessageRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {string} fileName
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadTicketAttachment(
      uid: string,
      fileName: string,
      body: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uploadTicketAttachment(
          uid,
          fileName,
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUuid
     * @param {string} fileName
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadTicketMessageAttachment(
      uid: string,
      messageUuid: string,
      fileName: string,
      body: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uploadTicketMessageAttachment(
          uid,
          messageUuid,
          fileName,
          body,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * TicketsControllerApi - factory interface
 * @export
 */
export const TicketsControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TicketsControllerApiFp(configuration);
  return {
    /**
     *
     * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToBlacklist(
      createBlacklistRecordRequest: CreateBlacklistRecordRequest,
      options?: any,
    ): AxiosPromise<TicketBlacklist> {
      return localVarFp
        .addUserToBlacklist(createBlacklistRecordRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    closeTicketByUid(
      uid: string,
      options?: any,
    ): AxiosPromise<ChangeTicketStateResponse> {
      return localVarFp
        .closeTicketByUid(uid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {PredefinedMessageRequest} predefinedMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPredefinedMessage(
      uuid: string,
      predefinedMessageRequest: PredefinedMessageRequest,
      options?: any,
    ): AxiosPromise<PredefinedMessage> {
      return localVarFp
        .createPredefinedMessage(uuid, predefinedMessageRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateTicketRequest} createTicketRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTicket(
      createTicketRequest: CreateTicketRequest,
      options?: any,
    ): AxiosPromise<TicketDTO> {
      return localVarFp
        .createTicket(createTicketRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessage(
      uid: string,
      messageUid: string,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .deleteMessage(uid, messageUid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePredefinedMessage(
      uuid: string,
      id: number,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .deletePredefinedMessage(uuid, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUid
     * @param {SendTicketMessageRequest} sendTicketMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMessage(
      uid: string,
      messageUid: string,
      sendTicketMessageRequest: SendTicketMessageRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .editMessage(uid, messageUid, sendTicketMessageRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlacklist(
      page: number,
      perPage: number,
      options?: any,
    ): AxiosPromise<ResponsePageTicketBlacklistDTO> {
      return localVarFp
        .getBlacklist(page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {HelperStatsRequest} helperStatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHelperStats(
      uuid: string,
      helperStatsRequest: HelperStatsRequest,
      options?: any,
    ): AxiosPromise<HelperStats> {
      return localVarFp
        .getHelperStats(uuid, helperStatsRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {HelpersStatsRequest} helpersStatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHelpersStats(
      helpersStatsRequest: HelpersStatsRequest,
      options?: any,
    ): AxiosPromise<Array<HelperStats>> {
      return localVarFp
        .getHelpersStats(helpersStatsRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPredefinedMessages(
      uuid: string,
      options?: any,
    ): AxiosPromise<Array<PredefinedMessage>> {
      return localVarFp
        .getPredefinedMessages(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRatings(uuid: string, options?: any): AxiosPromise<Array<TicketRating>> {
      return localVarFp
        .getRatings(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketAttachment(
      uid: string,
      fileName: string,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getTicketAttachment(uid, fileName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketByUid(uid: string, options?: any): AxiosPromise<TicketDTO> {
      return localVarFp
        .getTicketByUid(uid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUuid
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketMessageAttachment(
      uid: string,
      messageUuid: string,
      fileName: string,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getTicketMessageAttachment(uid, messageUuid, fileName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketTypes(options?: any): AxiosPromise<Array<TicketType>> {
      return localVarFp
        .getTicketTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} page
     * @param {number} perPage
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {TicketFilters} [ticketFilters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTickets(
      page: number,
      perPage: number,
      sortBy?: string,
      sortDirection?: string,
      ticketFilters?: TicketFilters,
      options?: any,
    ): AxiosPromise<ResponsePageTicketInfo> {
      return localVarFp
        .getTickets(
          page,
          perPage,
          sortBy,
          sortDirection,
          ticketFilters,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {string} [sortBy]
     * @param {string} [sortDirection]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserTicketsByUserUuid(
      uuid: string,
      page: number,
      perPage: number,
      sortBy?: string,
      sortDirection?: string,
      options?: any,
    ): AxiosPromise<ResponsePageTicketInfo> {
      return localVarFp
        .getUserTicketsByUserUuid(
          uuid,
          page,
          perPage,
          sortBy,
          sortDirection,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isUserBlacklisted(
      uuid: string,
      options?: any,
    ): AxiosPromise<TicketBlacklist> {
      return localVarFp
        .isUserBlacklisted(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {SendTicketMessageRequest} sendTicketMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMessage(
      uid: string,
      sendTicketMessageRequest: SendTicketMessageRequest,
      options?: any,
    ): AxiosPromise<TicketMessageDTO> {
      return localVarFp
        .postMessage(uid, sendTicketMessageRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {RateTicketRequest} rateTicketRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rateTicketByUid(
      uid: string,
      rateTicketRequest: RateTicketRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .rateTicketByUid(uid, rateTicketRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeBlacklistRecord(
      id: number,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .removeBlacklistRecord(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reopenTicketByUid(
      uid: string,
      options?: any,
    ): AxiosPromise<ChangeTicketStateResponse> {
      return localVarFp
        .reopenTicketByUid(uid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rewardCoins(uid: string, options?: any): AxiosPromise<ResultResponse> {
      return localVarFp
        .rewardCoins(uid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketDuplicate(
      uid: string,
      options?: any,
    ): AxiosPromise<SetDuplicateResponse> {
      return localVarFp
        .setTicketDuplicate(uid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {ChangeTicketHeadRequest} changeTicketHeadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketHead(
      uid: string,
      changeTicketHeadRequest: ChangeTicketHeadRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .setTicketHead(uid, changeTicketHeadRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {SetTicketNoteRequest} setTicketNoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketNote(
      uid: string,
      setTicketNoteRequest: SetTicketNoteRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .setTicketNote(uid, setTicketNoteRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {SetStarRequest} setStarRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketStar(
      uid: string,
      setStarRequest: SetStarRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .setTicketStar(uid, setStarRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {ChangeTicketStateRequest} changeTicketStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setTicketState(
      uid: string,
      changeTicketStateRequest: ChangeTicketStateRequest,
      options?: any,
    ): AxiosPromise<ChangeTicketStateResponse> {
      return localVarFp
        .setTicketState(uid, changeTicketStateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} id
     * @param {PredefinedMessageRequest} predefinedMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePredefinedMessage(
      uuid: string,
      id: number,
      predefinedMessageRequest: PredefinedMessageRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .updatePredefinedMessage(uuid, id, predefinedMessageRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {string} fileName
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadTicketAttachment(
      uid: string,
      fileName: string,
      body: string,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .uploadTicketAttachment(uid, fileName, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uid
     * @param {string} messageUuid
     * @param {string} fileName
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadTicketMessageAttachment(
      uid: string,
      messageUuid: string,
      fileName: string,
      body: string,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .uploadTicketMessageAttachment(
          uid,
          messageUuid,
          fileName,
          body,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TicketsControllerApi - object-oriented interface
 * @export
 * @class TicketsControllerApi
 * @extends {BaseAPI}
 */
export class TicketsControllerApi extends BaseAPI {
  /**
   *
   * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public addUserToBlacklist(
    createBlacklistRecordRequest: CreateBlacklistRecordRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .addUserToBlacklist(createBlacklistRecordRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public closeTicketByUid(uid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .closeTicketByUid(uid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {PredefinedMessageRequest} predefinedMessageRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public createPredefinedMessage(
    uuid: string,
    predefinedMessageRequest: PredefinedMessageRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .createPredefinedMessage(uuid, predefinedMessageRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateTicketRequest} createTicketRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public createTicket(
    createTicketRequest: CreateTicketRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .createTicket(createTicketRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {string} messageUid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public deleteMessage(
    uid: string,
    messageUid: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .deleteMessage(uid, messageUid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public deletePredefinedMessage(
    uuid: string,
    id: number,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .deletePredefinedMessage(uuid, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {string} messageUid
   * @param {SendTicketMessageRequest} sendTicketMessageRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public editMessage(
    uid: string,
    messageUid: string,
    sendTicketMessageRequest: SendTicketMessageRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .editMessage(uid, messageUid, sendTicketMessageRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} page
   * @param {number} perPage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getBlacklist(
    page: number,
    perPage: number,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .getBlacklist(page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {HelperStatsRequest} helperStatsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getHelperStats(
    uuid: string,
    helperStatsRequest: HelperStatsRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .getHelperStats(uuid, helperStatsRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {HelpersStatsRequest} helpersStatsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getHelpersStats(
    helpersStatsRequest: HelpersStatsRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .getHelpersStats(helpersStatsRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getPredefinedMessages(uuid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .getPredefinedMessages(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getRatings(uuid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .getRatings(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {string} fileName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getTicketAttachment(
    uid: string,
    fileName: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .getTicketAttachment(uid, fileName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getTicketByUid(uid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .getTicketByUid(uid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {string} messageUuid
   * @param {string} fileName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getTicketMessageAttachment(
    uid: string,
    messageUuid: string,
    fileName: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .getTicketMessageAttachment(uid, messageUuid, fileName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getTicketTypes(options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .getTicketTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} page
   * @param {number} perPage
   * @param {string} [sortBy]
   * @param {string} [sortDirection]
   * @param {TicketFilters} [ticketFilters]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getTickets(
    page: number,
    perPage: number,
    sortBy?: string,
    sortDirection?: string,
    ticketFilters?: TicketFilters,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .getTickets(page, perPage, sortBy, sortDirection, ticketFilters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} page
   * @param {number} perPage
   * @param {string} [sortBy]
   * @param {string} [sortDirection]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public getUserTicketsByUserUuid(
    uuid: string,
    page: number,
    perPage: number,
    sortBy?: string,
    sortDirection?: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .getUserTicketsByUserUuid(
        uuid,
        page,
        perPage,
        sortBy,
        sortDirection,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public isUserBlacklisted(uuid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .isUserBlacklisted(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {SendTicketMessageRequest} sendTicketMessageRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public postMessage(
    uid: string,
    sendTicketMessageRequest: SendTicketMessageRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .postMessage(uid, sendTicketMessageRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {RateTicketRequest} rateTicketRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public rateTicketByUid(
    uid: string,
    rateTicketRequest: RateTicketRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .rateTicketByUid(uid, rateTicketRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public removeBlacklistRecord(id: number, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .removeBlacklistRecord(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public reopenTicketByUid(uid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .reopenTicketByUid(uid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public rewardCoins(uid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .rewardCoins(uid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public setTicketDuplicate(uid: string, options?: AxiosRequestConfig) {
    return TicketsControllerApiFp(this.configuration)
      .setTicketDuplicate(uid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {ChangeTicketHeadRequest} changeTicketHeadRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public setTicketHead(
    uid: string,
    changeTicketHeadRequest: ChangeTicketHeadRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .setTicketHead(uid, changeTicketHeadRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {SetTicketNoteRequest} setTicketNoteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public setTicketNote(
    uid: string,
    setTicketNoteRequest: SetTicketNoteRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .setTicketNote(uid, setTicketNoteRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {SetStarRequest} setStarRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public setTicketStar(
    uid: string,
    setStarRequest: SetStarRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .setTicketStar(uid, setStarRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {ChangeTicketStateRequest} changeTicketStateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public setTicketState(
    uid: string,
    changeTicketStateRequest: ChangeTicketStateRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .setTicketState(uid, changeTicketStateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} id
   * @param {PredefinedMessageRequest} predefinedMessageRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public updatePredefinedMessage(
    uuid: string,
    id: number,
    predefinedMessageRequest: PredefinedMessageRequest,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .updatePredefinedMessage(uuid, id, predefinedMessageRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {string} fileName
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public uploadTicketAttachment(
    uid: string,
    fileName: string,
    body: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .uploadTicketAttachment(uid, fileName, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uid
   * @param {string} messageUuid
   * @param {string} fileName
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketsControllerApi
   */
  public uploadTicketMessageAttachment(
    uid: string,
    messageUuid: string,
    fileName: string,
    body: string,
    options?: AxiosRequestConfig,
  ) {
    return TicketsControllerApiFp(this.configuration)
      .uploadTicketMessageAttachment(uid, messageUuid, fileName, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
