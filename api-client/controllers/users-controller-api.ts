/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
// @ts-ignore
import { ChangeNickRequest } from "../models";
// @ts-ignore
import { ChangeNickResponse } from "../models";
// @ts-ignore
import { GroupDTO } from "../models";
// @ts-ignore
import { MigrateDelayDTO } from "../models";
// @ts-ignore
import { Permission } from "../models";
// @ts-ignore
import { ResponsePageBanRecordDTO } from "../models";
// @ts-ignore
import { ResponsePageCoinsLogDTO } from "../models";
// @ts-ignore
import { ResponsePageCoinsTransactionLogDTO } from "../models";
// @ts-ignore
import { ResponsePageCrateLog } from "../models";
// @ts-ignore
import { ResponsePageMigrateLogDTO } from "../models";
// @ts-ignore
import { ResponsePageMuteRecordDTO } from "../models";
// @ts-ignore
import { ResultResponse } from "../models";
// @ts-ignore
import { SetAgreementRequest } from "../models";
// @ts-ignore
import { SetIPWhitelistRequest } from "../models";
// @ts-ignore
import { SetPremiumRequest } from "../models";
// @ts-ignore
import { UpdateEmailRequest } from "../models";
// @ts-ignore
import { UserInfo } from "../models";
// @ts-ignore
import { UserProfile } from "../models";
// @ts-ignore
import { UserSpecificStats } from "../models";
// @ts-ignore
import { UserStats } from "../models";
/**
 * UsersControllerApi - axios parameter creator
 * @export
 */
export const UsersControllerApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} uuid
     * @param {ChangeNickRequest} changeNickRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeNick: async (
      uuid: string,
      changeNickRequest: ChangeNickRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("changeNick", "uuid", uuid);
      // verify required parameter 'changeNickRequest' is not null or undefined
      assertParamExists("changeNick", "changeNickRequest", changeNickRequest);
      const localVarPath = `/users/{uuid}/changenick`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeNickRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("deleteAccount", "uuid", uuid);
      const localVarPath = `/users/{uuid}`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMigrateDelay: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("deleteMigrateDelay", "uuid", uuid);
      const localVarPath = `/users/{uuid}/migrations/delay`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doesUserExist: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("doesUserExist", "id", id);
      const localVarPath = `/users/{id}/exists`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBansByUUID: async (
      uuid: string,
      page: number,
      perPage: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getBansByUUID", "uuid", uuid);
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getBansByUUID", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getBansByUUID", "perPage", perPage);
      const localVarPath = `/users/{uuid}/bans/{page}/{perPage}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoinsLogByUUID: async (
      uuid: string,
      page: number,
      perPage: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getCoinsLogByUUID", "uuid", uuid);
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getCoinsLogByUUID", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getCoinsLogByUUID", "perPage", perPage);
      const localVarPath = `/users/{uuid}/coins/transactions/{page}/{perPage}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoinsTransfersLogByUUID: async (
      uuid: string,
      page: number,
      perPage: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getCoinsTransfersLogByUUID", "uuid", uuid);
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getCoinsTransfersLogByUUID", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getCoinsTransfersLogByUUID", "perPage", perPage);
      const localVarPath = `/users/{uuid}/coins/transfers/{page}/{perPage}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCratesLogByUUID: async (
      uuid: string,
      page: number,
      perPage: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getCratesLogByUUID", "uuid", uuid);
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getCratesLogByUUID", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getCratesLogByUUID", "perPage", perPage);
      const localVarPath = `/users/{uuid}/crates/{page}/{perPage}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMigrateDelay: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getMigrateDelay", "uuid", uuid);
      const localVarPath = `/users/{uuid}/migrations/delay`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMigrationsByUUID: async (
      uuid: string,
      page: number,
      perPage: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getMigrationsByUUID", "uuid", uuid);
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getMigrationsByUUID", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getMigrationsByUUID", "perPage", perPage);
      const localVarPath = `/users/{uuid}/migrations/{page}/{perPage}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMutesByUUID: async (
      uuid: string,
      page: number,
      perPage: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getMutesByUUID", "uuid", uuid);
      // verify required parameter 'page' is not null or undefined
      assertParamExists("getMutesByUUID", "page", page);
      // verify required parameter 'perPage' is not null or undefined
      assertParamExists("getMutesByUUID", "perPage", perPage);
      const localVarPath = `/users/{uuid}/mutes/{page}/{perPage}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(`{${"page"}}`, encodeURIComponent(String(page)))
        .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUUID: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getProfileByUUID", "uuid", uuid);
      const localVarPath = `/users/{uuid}/profile`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatsByUuid: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getStatsByUuid", "uuid", uuid);
      const localVarPath = `/users/{uuid}/stats`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {string} parentMiniGame
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatsByUuidAndParentMiniGame: async (
      uuid: string,
      parentMiniGame: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getStatsByUuidAndParentMiniGame", "uuid", uuid);
      // verify required parameter 'parentMiniGame' is not null or undefined
      assertParamExists(
        "getStatsByUuidAndParentMiniGame",
        "parentMiniGame",
        parentMiniGame,
      );
      const localVarPath = `/users/{uuid}/stats/{parentMiniGame}`
        .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
        .replace(
          `{${"parentMiniGame"}}`,
          encodeURIComponent(String(parentMiniGame)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroupByUUID: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getUserGroupByUUID", "uuid", uuid);
      const localVarPath = `/users/{uuid}/groups`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfoBy: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getUserInfoBy", "id", id);
      const localVarPath = `/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfoByUuid: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPermissions: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("getUserPermissions", "uuid", uuid);
      const localVarPath = `/users/{uuid}/permissions`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} ip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByIP: async (
      ip: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ip' is not null or undefined
      assertParamExists("getUsersByIP", "ip", ip);
      const localVarPath = `/users/ip/{ip}`.replace(
        `{${"ip"}}`,
        encodeURIComponent(String(ip)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {SetAgreementRequest} setAgreementRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAgreement: async (
      uuid: string,
      setAgreementRequest: SetAgreementRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("setAgreement", "uuid", uuid);
      // verify required parameter 'setAgreementRequest' is not null or undefined
      assertParamExists(
        "setAgreement",
        "setAgreementRequest",
        setAgreementRequest,
      );
      const localVarPath = `/users/{uuid}/agreement`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setAgreementRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {SetIPWhitelistRequest} setIPWhitelistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setIPWhitelist: async (
      uuid: string,
      setIPWhitelistRequest: SetIPWhitelistRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("setIPWhitelist", "uuid", uuid);
      // verify required parameter 'setIPWhitelistRequest' is not null or undefined
      assertParamExists(
        "setIPWhitelist",
        "setIPWhitelistRequest",
        setIPWhitelistRequest,
      );
      const localVarPath = `/users/{uuid}/ipwhitelist`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setIPWhitelistRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMigrateDelay: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("setMigrateDelay", "uuid", uuid);
      const localVarPath = `/users/{uuid}/migrations/delay`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {SetPremiumRequest} setPremiumRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPremium: async (
      uuid: string,
      setPremiumRequest: SetPremiumRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("setPremium", "uuid", uuid);
      // verify required parameter 'setPremiumRequest' is not null or undefined
      assertParamExists("setPremium", "setPremiumRequest", setPremiumRequest);
      const localVarPath = `/users/{uuid}/premium`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setPremiumRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} uuid
     * @param {UpdateEmailRequest} updateEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEmail: async (
      uuid: string,
      updateEmailRequest: UpdateEmailRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists("updateEmail", "uuid", uuid);
      // verify required parameter 'updateEmailRequest' is not null or undefined
      assertParamExists(
        "updateEmail",
        "updateEmailRequest",
        updateEmailRequest,
      );
      const localVarPath = `/users/{uuid}/email`.replace(
        `{${"uuid"}}`,
        encodeURIComponent(String(uuid)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateEmailRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersControllerApi - functional programming interface
 * @export
 */
export const UsersControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UsersControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} uuid
     * @param {ChangeNickRequest} changeNickRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeNick(
      uuid: string,
      changeNickRequest: ChangeNickRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ChangeNickResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changeNick(
        uuid,
        changeNickRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAccount(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(
        uuid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMigrateDelay(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteMigrateDelay(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doesUserExist(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.doesUserExist(
        id,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBansByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageBanRecordDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBansByUUID(
        uuid,
        page,
        perPage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCoinsLogByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageCoinsLogDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCoinsLogByUUID(
          uuid,
          page,
          perPage,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCoinsTransfersLogByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageCoinsTransactionLogDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCoinsTransfersLogByUUID(
          uuid,
          page,
          perPage,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCratesLogByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageCrateLog>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCratesLogByUUID(
          uuid,
          page,
          perPage,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMigrateDelay(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MigrateDelayDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrateDelay(
        uuid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMigrationsByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageMigrateLogDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMigrationsByUUID(
          uuid,
          page,
          perPage,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMutesByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponsePageMuteRecordDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMutesByUUID(
        uuid,
        page,
        perPage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProfileByUUID(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProfileByUUID(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatsByUuid(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStats>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatsByUuid(
        uuid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {string} parentMiniGame
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatsByUuidAndParentMiniGame(
      uuid: string,
      parentMiniGame: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserSpecificStats>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getStatsByUuidAndParentMiniGame(
          uuid,
          parentMiniGame,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserGroupByUUID(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<GroupDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserGroupByUUID(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserInfoBy(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfoBy(
        id,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserInfoByUuid(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserInfoByUuid(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserPermissions(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Set<Permission>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserPermissions(uuid, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} ip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersByIP(
      ip: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserProfile>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByIP(
        ip,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {SetAgreementRequest} setAgreementRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAgreement(
      uuid: string,
      setAgreementRequest: SetAgreementRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAgreement(
        uuid,
        setAgreementRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {SetIPWhitelistRequest} setIPWhitelistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setIPWhitelist(
      uuid: string,
      setIPWhitelistRequest: SetIPWhitelistRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setIPWhitelist(
        uuid,
        setIPWhitelistRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setMigrateDelay(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MigrateDelayDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setMigrateDelay(
        uuid,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {SetPremiumRequest} setPremiumRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPremium(
      uuid: string,
      setPremiumRequest: SetPremiumRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setPremium(
        uuid,
        setPremiumRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} uuid
     * @param {UpdateEmailRequest} updateEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEmail(
      uuid: string,
      updateEmailRequest: UpdateEmailRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmail(
        uuid,
        updateEmailRequest,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * UsersControllerApi - factory interface
 * @export
 */
export const UsersControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersControllerApiFp(configuration);
  return {
    /**
     *
     * @param {string} uuid
     * @param {ChangeNickRequest} changeNickRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeNick(
      uuid: string,
      changeNickRequest: ChangeNickRequest,
      options?: any,
    ): AxiosPromise<ChangeNickResponse> {
      return localVarFp
        .changeNick(uuid, changeNickRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(uuid: string, options?: any): AxiosPromise<ResultResponse> {
      return localVarFp
        .deleteAccount(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMigrateDelay(
      uuid: string,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .deleteMigrateDelay(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doesUserExist(id: string, options?: any): AxiosPromise<boolean> {
      return localVarFp
        .doesUserExist(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBansByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: any,
    ): AxiosPromise<ResponsePageBanRecordDTO> {
      return localVarFp
        .getBansByUUID(uuid, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoinsLogByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: any,
    ): AxiosPromise<ResponsePageCoinsLogDTO> {
      return localVarFp
        .getCoinsLogByUUID(uuid, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoinsTransfersLogByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: any,
    ): AxiosPromise<ResponsePageCoinsTransactionLogDTO> {
      return localVarFp
        .getCoinsTransfersLogByUUID(uuid, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCratesLogByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: any,
    ): AxiosPromise<ResponsePageCrateLog> {
      return localVarFp
        .getCratesLogByUUID(uuid, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMigrateDelay(
      uuid: string,
      options?: any,
    ): AxiosPromise<MigrateDelayDTO> {
      return localVarFp
        .getMigrateDelay(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMigrationsByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: any,
    ): AxiosPromise<ResponsePageMigrateLogDTO> {
      return localVarFp
        .getMigrationsByUUID(uuid, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {number} page
     * @param {number} perPage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMutesByUUID(
      uuid: string,
      page: number,
      perPage: number,
      options?: any,
    ): AxiosPromise<ResponsePageMuteRecordDTO> {
      return localVarFp
        .getMutesByUUID(uuid, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProfileByUUID(uuid: string, options?: any): AxiosPromise<UserProfile> {
      return localVarFp
        .getProfileByUUID(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatsByUuid(uuid: string, options?: any): AxiosPromise<UserStats> {
      return localVarFp
        .getStatsByUuid(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {string} parentMiniGame
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatsByUuidAndParentMiniGame(
      uuid: string,
      parentMiniGame: string,
      options?: any,
    ): AxiosPromise<UserSpecificStats> {
      return localVarFp
        .getStatsByUuidAndParentMiniGame(uuid, parentMiniGame, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroupByUUID(
      uuid: string,
      options?: any,
    ): AxiosPromise<Set<GroupDTO>> {
      return localVarFp
        .getUserGroupByUUID(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfoBy(id: string, options?: any): AxiosPromise<UserInfo> {
      return localVarFp
        .getUserInfoBy(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfoByUuid(options?: any): AxiosPromise<UserInfo> {
      return localVarFp
        .getUserInfoByUuid(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserPermissions(
      uuid: string,
      options?: any,
    ): AxiosPromise<Set<Permission>> {
      return localVarFp
        .getUserPermissions(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} ip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByIP(ip: string, options?: any): AxiosPromise<Array<UserProfile>> {
      return localVarFp
        .getUsersByIP(ip, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {SetAgreementRequest} setAgreementRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAgreement(
      uuid: string,
      setAgreementRequest: SetAgreementRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .setAgreement(uuid, setAgreementRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {SetIPWhitelistRequest} setIPWhitelistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setIPWhitelist(
      uuid: string,
      setIPWhitelistRequest: SetIPWhitelistRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .setIPWhitelist(uuid, setIPWhitelistRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMigrateDelay(
      uuid: string,
      options?: any,
    ): AxiosPromise<MigrateDelayDTO> {
      return localVarFp
        .setMigrateDelay(uuid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {SetPremiumRequest} setPremiumRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPremium(
      uuid: string,
      setPremiumRequest: SetPremiumRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .setPremium(uuid, setPremiumRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} uuid
     * @param {UpdateEmailRequest} updateEmailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEmail(
      uuid: string,
      updateEmailRequest: UpdateEmailRequest,
      options?: any,
    ): AxiosPromise<ResultResponse> {
      return localVarFp
        .updateEmail(uuid, updateEmailRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersControllerApi - object-oriented interface
 * @export
 * @class UsersControllerApi
 * @extends {BaseAPI}
 */
export class UsersControllerApi extends BaseAPI {
  /**
   *
   * @param {string} uuid
   * @param {ChangeNickRequest} changeNickRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public changeNick(
    uuid: string,
    changeNickRequest: ChangeNickRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .changeNick(uuid, changeNickRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public deleteAccount(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .deleteAccount(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public deleteMigrateDelay(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .deleteMigrateDelay(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public doesUserExist(id: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .doesUserExist(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} page
   * @param {number} perPage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getBansByUUID(
    uuid: string,
    page: number,
    perPage: number,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .getBansByUUID(uuid, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} page
   * @param {number} perPage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getCoinsLogByUUID(
    uuid: string,
    page: number,
    perPage: number,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .getCoinsLogByUUID(uuid, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} page
   * @param {number} perPage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getCoinsTransfersLogByUUID(
    uuid: string,
    page: number,
    perPage: number,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .getCoinsTransfersLogByUUID(uuid, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} page
   * @param {number} perPage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getCratesLogByUUID(
    uuid: string,
    page: number,
    perPage: number,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .getCratesLogByUUID(uuid, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getMigrateDelay(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getMigrateDelay(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} page
   * @param {number} perPage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getMigrationsByUUID(
    uuid: string,
    page: number,
    perPage: number,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .getMigrationsByUUID(uuid, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {number} page
   * @param {number} perPage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getMutesByUUID(
    uuid: string,
    page: number,
    perPage: number,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .getMutesByUUID(uuid, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getProfileByUUID(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getProfileByUUID(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getStatsByUuid(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getStatsByUuid(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {string} parentMiniGame
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getStatsByUuidAndParentMiniGame(
    uuid: string,
    parentMiniGame: string,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .getStatsByUuidAndParentMiniGame(uuid, parentMiniGame, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getUserGroupByUUID(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getUserGroupByUUID(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getUserInfoBy(id: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getUserInfoBy(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getUserInfoByUuid(options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getUserInfoByUuid(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getUserPermissions(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getUserPermissions(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} ip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public getUsersByIP(ip: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .getUsersByIP(ip, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {SetAgreementRequest} setAgreementRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public setAgreement(
    uuid: string,
    setAgreementRequest: SetAgreementRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .setAgreement(uuid, setAgreementRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {SetIPWhitelistRequest} setIPWhitelistRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public setIPWhitelist(
    uuid: string,
    setIPWhitelistRequest: SetIPWhitelistRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .setIPWhitelist(uuid, setIPWhitelistRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public setMigrateDelay(uuid: string, options?: AxiosRequestConfig) {
    return UsersControllerApiFp(this.configuration)
      .setMigrateDelay(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {SetPremiumRequest} setPremiumRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public setPremium(
    uuid: string,
    setPremiumRequest: SetPremiumRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .setPremium(uuid, setPremiumRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} uuid
   * @param {UpdateEmailRequest} updateEmailRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersControllerApi
   */
  public updateEmail(
    uuid: string,
    updateEmailRequest: UpdateEmailRequest,
    options?: AxiosRequestConfig,
  ) {
    return UsersControllerApiFp(this.configuration)
      .updateEmail(uuid, updateEmailRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
